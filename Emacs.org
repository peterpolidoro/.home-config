#+title: Peter Polidoro Emacs Configuration
#+AUTHOR: Peter Polidoro
#+EMAIL: peter@polidoro.io
#+PROPERTY: header-args:emacs-lisp :tangle ./.emacs.d/init.el

* Introduction

This initialization file is based on David Wilson's awesome Emacs configuration: https://github.com/daviwil

This file generates [[file:init.el][init.el]] which will be loaded by Emacs at startup.

#+begin_src emacs-lisp

;; NOTE: init.el is generated from Emacs.org.  Please edit that file
;;       in Emacs and init.el will be generated automatically!

#+end_src

* Setup

** Who am I?

#+begin_src emacs-lisp

(setq user-full-name "Peter Polidoro"
      user-mail-address "peter@polidoro.io")
(setq copyright-names-regexp
      (format "%s <%s>" user-full-name user-mail-address))

#+end_src

** Font Size

#+begin_src emacs-lisp

;; Adjust this font size for each system
(defvar pjp/default-font-size 120)
(defvar pjp/default-variable-font-size 120)

#+end_src

** Frame transparency

#+begin_src emacs-lisp

;; Make frame transparency overridable
(defvar pjp/frame-transparency '(95 . 95))

#+end_src

* Handle Warnings

** Set minimum warning level

#+begin_src emacs-lisp

(setq warning-minimum-level :error)

#+end_src

** Remove cl is deprecated warning

#+begin_src emacs-lisp

;;(require 'loadhist)
;;(file-dependents (feature-file 'cl))
(setq byte-compile-warnings '(cl-functions))

#+end_src

* Startup Performance

Make startup faster by reducing the frequency of garbage collection and then
use a hook to measure Emacs startup time.

#+begin_src emacs-lisp

;; The default is 800 kilobytes.  Measured in bytes.
(setq gc-cons-threshold (* 50 1000 1000))

;; Profile emacs startup
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "*** Emacs loaded in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))

#+end_src

* Package Management

Use =Guix= to install package repositories and load =use-package= to
manage package configuration.

** use-package

#+begin_src emacs-lisp

(setq pjp/is-gnu (or (eq system-type 'gnu/linux) (eq system-type 'gnu)))
(setq pjp/is-guix-system (and pjp/is-gnu
                              (require 'f)
                              (string-equal (f-read "/etc/issue")
                                            "\nThis is the GNU system.  Welcome.\n")))

(if pjp/is-gnu
    (setq use-package-always-ensure nil)
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
												   ("melpa-stable" . "https://stable.melpa.org/packages/")
												   ("org" . "https://orgmode.org/elpa/")
												   ("elpa" . "https://elpa.gnu.org/packages/")))
  (package-initialize)
  (unless package-archive-contents
	  (package-refresh-contents))
  (unless (package-installed-p 'use-package)
	  (package-install 'use-package))
  (require 'use-package-ensure)
  (setq use-package-always-ensure t))

(eval-when-compile
  (require 'use-package))
;; (require 'diminish)
(require 'bind-key)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-use-package"

#+end_src

** Guix

#+begin_src emacs-lisp

(add-hook 'scheme-mode-hook 'guix-devel-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-guix"

"guile"

"guix"

#+end_src

* Keep .emacs.d Clean

I don't want a bunch of transient files showing up as untracked in the Git
repo so I move them all to another location.

#+begin_src emacs-lisp

;; Keep transient cruft out of ~/.emacs.d/
(setq user-emacs-directory "~/.cache/emacs/"
      backup-directory-alist `(("." . ,(expand-file-name "backups" user-emacs-directory)))
      undo-tree-history-directory-alist `(("." . ,(expand-file-name "undo" user-emacs-directory)))
      url-history-file (expand-file-name "url/history" user-emacs-directory)
      auto-save-list-file-prefix (expand-file-name "auto-save-list/.saves-" user-emacs-directory)
      projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" user-emacs-directory))

;; Use no-littering to automatically set common paths to the new user-emacs-directory
(use-package no-littering)

;; Keep customization settings in a temporary file
(setq custom-file
      (if (boundp 'server-socket-dir)
          (expand-file-name "custom.el" server-socket-dir)
        (expand-file-name (format "emacs-custom-%s.el" (user-uid)) temporary-file-directory)))
(load custom-file t)

;; I use version control instead of backup files
(setq make-backup-files nil)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-no-littering"

#+end_src

* Update Load Path

I've got a folder of custom Emacs Lisp libraries which must be added to the load path.

#+begin_src emacs-lisp

;; Add my library path to load-path
(push "~/.dotfiles/.emacs.d/lisp" load-path)

#+end_src

* Server Mode

Start the Emacs server from this instance so that all =emacsclient= calls are routed here.

#+begin_src emacs-lisp

;; (server-start)

#+end_src

* Keyboard Bindings
** ESC Cancels All

#+begin_src emacs-lisp

(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

#+end_src

** Keybinding Panel (which-key)

[[https://github.com/justbur/emacs-which-key][which-key]] is great for getting an overview of what keybindings are available
based on the prefix keys you entered.

#+begin_src emacs-lisp

(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.3))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-which-key"

#+end_src

* General Configuration

** User Interface

*** Clean up Emacs' user interface, make it more minimal.

#+begin_src emacs-lisp

(scroll-bar-mode -1)        ; Disable visible scrollbar
(tool-bar-mode -1)          ; Disable the toolbar

; Making tooltips appear in the echo area
(tooltip-mode -1)
(setq tooltip-use-echo-area t)

(set-fringe-mode 10)        ; Give some breathing room

(menu-bar-mode -1)            ; Disable the menu bar

;; Set up the visible bell
(setq visible-bell t)

#+end_src

*** Modifying prompts

#+begin_src emacs-lisp

(setq inhibit-startup-message t
      inhibit-startup-echo-area-message t)
(setq use-short-answers t)
(setq confirm-nonexistent-file-or-buffer nil)
(setq kill-buffer-query-functions
  (remq 'process-kill-buffer-query-function
         kill-buffer-query-functions))

#+end_src

*** Improve scrolling.

#+begin_src emacs-lisp

(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1)

#+end_src

*** Set frame transparency and maximize windows by default.

#+begin_src emacs-lisp

(set-frame-parameter (selected-frame) 'alpha pjp/frame-transparency)
(add-to-list 'default-frame-alist `(alpha . ,pjp/frame-transparency))
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))

#+end_src

*** Switching buffers

[[https://www.masteringemacs.org/article/demystifying-emacs-window-manager]]

#+begin_src emacs-lisp

(setq switch-to-buffer-obey-display-actions t)

#+end_src

*** Enable line numbers and customize their format.

#+begin_src emacs-lisp

(column-number-mode)

;; Enable line numbers for some modes
(dolist (mode '(text-mode-hook
                prog-mode-hook
                conf-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 1))))

;; Disable line numbers for some modes
(dolist (mode '(org-mode-hook
                term-mode-hook
                shell-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src

*** Don't warn for large files (shows up when launching videos)

#+begin_src emacs-lisp

(setq large-file-warning-threshold nil)

#+end_src

*** Don't warn for following symlinked files

#+begin_src emacs-lisp

(setq vc-follow-symlinks t)

#+end_src

*** Don't warn when advice is added for functions

#+begin_src emacs-lisp

(setq ad-redefinition-action 'accept)

#+end_src

*** Kill whole line

#+BEGIN_SRC emacs-lisp
(setq kill-whole-line t)
#+END_SRC

*** Fill-column

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC

*** Treat camel case as separate words

#+begin_src emacs-lisp

(add-hook 'prog-mode-hook 'subword-mode)

#+end_src

*** Make scripts executable

#+begin_src emacs-lisp

(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

#+end_src

*** Single space after periods

#+begin_src emacs-lisp

(setq sentence-end-double-space nil)

#+end_src

*** Visual Line Mode

#+begin_src emacs-lisp

(global-visual-line-mode t)

#+end_src

*** Offer to create parent directories on save

#+begin_src emacs-lisp

(add-hook 'before-save-hook
          (lambda ()
            (when buffer-file-name
              (let ((dir (file-name-directory buffer-file-name)))
                (when (and (not (file-exists-p dir))
                           (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                  (make-directory dir t))))))

#+end_src

*** Apply changes to higlighted region

#+begin_src emacs-lisp

(transient-mark-mode t)

#+end_src

*** Overwrite selected text

#+begin_src emacs-lisp

(delete-selection-mode t)

#+end_src

*** Refresh buffers when files change

#+begin_src emacs-lisp

(global-auto-revert-mode t)
(setq global-auto-revert-non-file-buffers t)

#+end_src

*** Yank to point on mouse click

#+begin_src emacs-lisp

(setq mouse-yank-at-point t)

#+end_src

*** Ensure files end with newline

#+begin_src emacs-lisp

(setq require-final-newline t)

#+end_src

*** Confirm closing Emacs

#+begin_src emacs-lisp

(setq confirm-kill-emacs 'y-or-n-p)

#+end_src

*** Use UTF-8

#+begin_src emacs-lisp

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

#+end_src

*** Use smartparens

#+begin_src emacs-lisp

(use-package smartparens
  :config
  (smartparens-global-mode t)

  (sp-pair "'" nil :actions :rem)
  (sp-pair "`" nil :actions :rem)
  (setq sp-highlight-pair-overlay nil))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-smartparens"

#+end_src

*** Truncate lines

#+begin_src emacs-lisp

(set-default 'truncate-lines t)
(setq truncate-partial-width-windows t)

#+end_src

*** Default tab width

#+begin_src emacs-lisp

(setq-default tab-width 2)

#+end_src

*** Windmove

#+begin_src emacs-lisp

(global-set-key (kbd "s-b")  'windmove-left)
(global-set-key (kbd "s-f") 'windmove-right)
(global-set-key (kbd "s-p")    'windmove-up)
(global-set-key (kbd "s-n")  'windmove-down)

#+end_src

*** Undo-Tree

#+begin_src emacs-lisp

(if pjp/is-gnu
    (use-package undo-tree
      :init
      (global-undo-tree-mode 1)))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-undo-tree"

#+end_src

*** Uniquify

#+begin_src emacs-lisp

(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
(setq-default frame-title-format "%b (%f)")

#+end_src

*** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic. Disable for now.

#+BEGIN_SRC emacs-lisp :tangle no

(defun pjp/split-window-below-and-switch ()
  "Split the window horizontally, then switch to the new pane."
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))

(defun pjp/split-window-right-and-switch ()
  "Split the window vertically, then switch to the new pane."
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))

(global-set-key (kbd "C-x 2") 'pjp/split-window-below-and-switch)
(global-set-key (kbd "C-x 3") 'pjp/split-window-right-and-switch)

#+END_SRC

*** Kill buffer diff

Custom kill command that provides the option to diff a modified buffer with the
file it is visiting.

#+BEGIN_SRC emacs-lisp

(defun pjp/kill-buffer ()
  (interactive)
  (catch 'quit
    (save-window-excursion
      (let (done)
        (when (and buffer-file-name (buffer-modified-p))
          (while (not done)
            (let ((response (read-char-choice
                             (format "Save file %s? (y, n, d, q) " (buffer-file-name))
                             '(?y ?n ?d ?q))))
              (setq done (cond
                          ((eq response ?q) (throw 'quit nil))
                          ((eq response ?y) (save-buffer) t)
                          ((eq response ?n) (set-buffer-modified-p nil) t)
                          ((eq response ?d) (diff-buffer-with-file) nil))))))
        (kill-buffer (current-buffer))))))

(global-set-key [remap kill-buffer] 'pjp/kill-buffer)

#+END_SRC

** Theme

#+begin_src emacs-lisp

(load-theme 'euphoria t t)
(enable-theme 'euphoria)
(setq color-theme-is-global t)
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-color-theme-modern"

#+end_src

** Font

*** Set the font

Fonts are installed from the "desktop" profile.

#+begin_src emacs-lisp

(when pjp/is-gnu
  (set-face-attribute 'default nil :font "Fira Code Retina" :height pjp/default-font-size)

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height pjp/default-font-size)

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil :font "Iosevka Aile" :height pjp/default-variable-font-size :weight 'regular))

#+end_src

*** Enable proper Unicode glyph support

#+begin_src emacs-lisp

(defun pjp/replace-unicode-font-mapping (block-name old-font new-font)
  (let* ((block-idx (cl-position-if
                     (lambda (i) (string-equal (car i) block-name))
                     unicode-fonts-block-font-mapping))
         (block-fonts (cadr (nth block-idx unicode-fonts-block-font-mapping)))
         (updated-block (cl-substitute new-font old-font block-fonts :test 'string-equal)))
    (setf (cdr (nth block-idx unicode-fonts-block-font-mapping))
          `(,updated-block))))

(use-package unicode-fonts
  :disabled
  :custom
  (unicode-fonts-skip-font-groups '(low-quality-glyphs))
  :config
  ;; Fix the font mappings to use the right emoji font
  (mapcar
   (lambda (block-name)
     (pjp/replace-unicode-font-mapping block-name "Apple Color Emoji" "Noto Color Emoji"))
   '("Dingbats"
     "Emoticons"
     "Miscellaneous Symbols and Pictographs"
     "Transport and Map Symbols"))
  (unicode-fonts-setup))

#+end_src

*** Emojis in buffers

#+begin_src emacs-lisp

(use-package emojify
  :hook (erc-mode . emojify-mode)
  :commands emojify-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-emojify"

#+end_src

*** All the icons

*NOTE:* The first time you load your configuration on a new machine, you'll need to run `M-x all-the-icons-install-fonts` so that icons display correctly.

#+begin_src emacs-lisp

(use-package all-the-icons)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-all-the-icons"

#+end_src

** Mode Line

*** Doom Mode Line

#+begin_src emacs-lisp

(use-package minions
  :hook (doom-modeline-mode . minions-mode))

(use-package doom-modeline
  :after eshell     ;; Make sure it gets hooked after eshell
  :hook (after-init . doom-modeline-init)
  :custom-face
  (mode-line ((t (:height 0.85))))
  (mode-line-inactive ((t (:height 0.85))))
  :custom
  (doom-modeline-height 15)
  (doom-modeline-bar-width 6)
  (doom-modeline-lsp t)
  (doom-modeline-github nil)
  (doom-modeline-mu4e nil)
  (doom-modeline-irc t)
  (doom-modeline-minor-modes t)
  (doom-modeline-persp-name nil)
  (doom-modeline-buffer-file-name-style 'truncate-except-project)
  (doom-modeline-major-mode-icon nil))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-minions"

"emacs-doom-modeline"

#+end_src

*** Basic Customization

#+begin_src emacs-lisp

(setq display-time-format "%l:%M %p %b %y"
      display-time-default-load-average nil)

#+end_src

*** Enable Mode Diminishing

The [[https://github.com/myrjola/diminish.el][diminish]] package hides pesky minor modes from the modelines.

#+begin_src emacs-lisp

(use-package diminish)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-diminish"

#+end_src

** Notifications

[[https://github.com/jwiegley/alert][alert]] is a great library for showing notifications from other packages in a
variety of ways. For now I just use it to surface desktop notifications from
package code.

#+begin_src emacs-lisp

(use-package alert
  :commands alert
  :config
  (setq alert-default-style 'notifications))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-alert"

#+end_src

** Auto-Saving Changed Files

#+begin_src emacs-lisp :tangle no

(use-package super-save
  :defer 1
  :diminish super-save-mode
  :config
  (super-save-mode +1)
  (setq super-save-auto-save-when-idle t))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

;;"emacs-super-save"

#+end_src

** Auto-Reverting Changed Files

#+begin_src emacs-lisp

(global-auto-revert-mode 1)

#+end_src

** Highlight Matching Braces

#+begin_src emacs-lisp

(use-package paren
  :config
  (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
  (show-paren-mode))

#+end_src

** Displaying World Time

=display-time-world= command provides a nice display of the time at a
specified list of timezones. Nice for working in a team with remote members.

#+begin_src emacs-lisp

(setq display-time-world-list
      '(("America/Los_Angeles" "California")
        ("America/New_York" "New York")
        ("Europe/Athens" "Athens")
        ("Pacific/Auckland" "Auckland")
        ("Asia/Shanghai" "Shanghai")))
(setq display-time-world-time-format "%a, %d %b %I:%M %p %Z")

#+end_src

** Pinentry

Emacs can be prompted for the PIN of GPG private keys, we just need to set
=epa-pinentry-mode= to accomplish that:

#+begin_src emacs-lisp

(when pjp/is-gnu
  (setq epa-pinentry-mode 'loopback)
  (pinentry-start))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-pinentry"

"pinentry-emacs"

#+end_src
** TRAMP

#+begin_src emacs-lisp

;; Set default connection mode to SSH
(setq tramp-default-method "ssh")

#+end_src

** Bind keys to change text size

#+begin_src emacs-lisp

(defhydra hydra-zoom (global-map "C-=")
  "zoom"
  ("=" text-scale-increase "in")
  ("-" text-scale-decrease "out"))

#+end_src

** Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs'
=describe-= command buffers. For example, if you use =describe-function=, you
will not only get the documentation about the function, you will also see the
source code of the function and where it gets used in other places in the
Emacs configuration. It is very useful for figuring out how things work in
Emacs.

#+begin_src emacs-lisp

(use-package helpful
  :bind
  ([remap describe-function] . helpful-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key)
  ;;("C-." . helpful-at-point)
  ("C-h c". helpful-command))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-helpful"

#+end_src
** Helpful and Help Buffer Placement

#+begin_src emacs-lisp

(defvar pjp/help-buffers '("^\\*Help\\*$"
                           "^\\*helpful"))

(while pjp/help-buffers
  (add-to-list 'display-buffer-alist
               `(,(car pjp/help-buffers)
                 (display-buffer-pop-up-frame)
                 ))
  (setq pjp/help-buffers (cdr pjp/help-buffers)))

#+end_src

* Stateful Keymaps with Hydra

#+begin_src emacs-lisp

(use-package hydra
  :defer 1)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-hydra"

#+end_src

* Completion System
** Vertico

#+begin_src emacs-lisp
(defun pjp/minibuffer-backward-kill (arg)
	"When minibuffer is completing a file name delete up to parent
		folder, otherwise delete a word"
	(interactive "p")
	(if minibuffer-completing-file-name
			;; Borrowed from https://github.com/raxod502/selectrum/issues/498#issuecomment-803283608
			(if (string-match-p "/." (minibuffer-contents))
					(zap-up-to-char (- arg) ?/)
				(delete-minibuffer-contents))
		(delete-word (- arg))))

(use-package vertico
	:bind (:map minibuffer-local-map
					    ("M-<backspace>" . pjp/minibuffer-backward-kill))
	:init
	(vertico-mode)

	;; Different scroll margin
	;; (setq vertico-scroll-margin 0)

	;; Show more candidates
	;; (setq vertico-count 20)

	;; Grow and shrink the Vertico minibuffer
	;; (setq vertico-resize t)

	;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
	(setq vertico-cycle t))

(use-package emacs
	:init
	;; Add prompt indicator to `completing-read-multiple'.
	;; Alternatively try `consult-completing-read-multiple'.
	(defun crm-indicator (args)
		(cons (concat "[CRM] " (car args)) (cdr args)))
	(advice-add #'completing-read-multiple :filter-args #'crm-indicator)

	;; Do not allow the cursor in the minibuffer prompt
	(setq minibuffer-prompt-properties
				'(read-only t cursor-intangible t face minibuffer-prompt))
	(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

	;; Emacs 28: Hide commands in M-x which do not work in the current mode.
	;; Vertico commands are hidden in normal buffers.
	;; (setq read-extended-command-predicate
	;;       #'command-completion-default-include-p)

	;; Enable recursive minibuffers
	(setq enable-recursive-minibuffers t)

	;; TAB cycle if there are only few candidates
	(setq completion-cycle-threshold 3)

	;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
	;; Corfu commands are hidden, since they are not supposed to be used via M-x.
	;; (setq read-extended-command-predicate
	;;       #'command-completion-default-include-p)

	;; Enable indentation+completion using the TAB key.
	;; `completion-at-point' is often bound to M-TAB.
	(setq tab-always-indent 'complete))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-vertico"

#+end_src

** Orderless

#+begin_src emacs-lisp

(use-package orderless
  :init
  ;; Configure a custom style dispatcher (see the Consult wiki)
  ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
  ;;       orderless-component-separator #'orderless-escapable-split-on-space)
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-orderless"

#+end_src

** Savehist

#+begin_src emacs-lisp

(setq history-length 25)
(use-package savehist
  :init
  (savehist-mode))

#+end_src

** Corfu

#+begin_src emacs-lisp

(use-package corfu
  ;; Optional customizations
  :custom
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  ;; (corfu-auto t)                 ;; Enable auto completion
  ;; (corfu-commit-predicate nil)   ;; Do not commit selected candidates on next input
  ;; (corfu-quit-at-boundary t)     ;; Automatically quit at word boundary
  ;; (corfu-quit-no-match t)        ;; Automatically quit if there is no match
  ;; (corfu-preview-current nil)    ;; Disable current candidate preview
  (corfu-preselect-first nil)    ;; Disable candidate preselection
  ;; (corfu-echo-documentation nil) ;; Disable documentation in the echo area
  ;; (corfu-scroll-margin 5)        ;; Use scroll margin

  :bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous))

  ;; You may want to enable Corfu only for certain modes.
  ;; :hook ((prog-mode . corfu-mode)
  ;;        (shell-mode . corfu-mode)
  ;;        (eshell-mode . corfu-mode))

  ;; Recommended: Enable Corfu globally.
  ;; This is recommended since dabbrev can be used globally (M-/).
  :init
  (global-corfu-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-corfu"

#+end_src

** Consult

Consult provides a lot of useful completion commands similar to Ivy's Counsel.

#+begin_src emacs-lisp

(use-package consult
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (("C-s" . consult-line)
         ;; C-c bindings (mode-specific-map)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-c k" . consult-kmacro)
         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ("<help> a" . consult-apropos)            ;; orig. apropos-command
         ;; M-g bindings (goto-map)
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi))           ;; needed by consult-line to detect isearch

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI. You may want to also
  ;; enable `consult-preview-at-point-mode` in Embark Collect buffers.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Optionally replace `completing-read-multiple' with an enhanced version.
  ;; (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key (kbd "M-."))
  ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme
   :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-recent-file consult--source-project-recent-file consult--source-bookmark
   :preview-key "M-.")

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; Optionally configure a function which returns the project root directory.
  ;; There are multiple reasonable alternatives to chose from.
  ;;;; 1. project.el (project-roots)
  (setq consult-project-root-function
        (lambda ()
          (when-let (project (project-current))
            (car (project-roots project)))))
  ;;;; 2. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-root-function #'projectile-project-root)
  ;;;; 3. vc.el (vc-root-dir)
  ;; (setq consult-project-root-function #'vc-root-dir)
  ;;;; 4. locate-dominating-file
  ;; (setq consult-project-root-function (lambda () (locate-dominating-file "." ".git")))
  )

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-consult"

#+end_src

** Marginalia

#+begin_src emacs-lisp

(use-package marginalia
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init configuration is always executed (Not lazy!)
  :init

  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-marginalia"

#+end_src
** Embark

#+begin_src emacs-lisp

(use-package embark
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("M-." . embark-dwim)        ;; good alternative: C-;
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :ensure t
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook
  (embark-collect-mode . consult-preview-at-point-mode)
  )

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-embark"

#+end_src

** Completion Ignored Extensions

#+begin_src emacs-lisp

(add-to-list 'completion-ignored-extensions ".go")

#+end_src

* Jumping with Avy

#+begin_src emacs-lisp

(use-package avy
  :commands (avy-goto-char avy-goto-word-0 avy-goto-line))

(use-package avy
  :bind (("C-:" . avy-goto-char)
         ("C-;" . avy-goto-char-2)
         ("M-g f" . avy-goto-line)
         ("M-g w" . avy-goto-word-1)
         ("M-g e" . avy-goto-word-0)))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-avy"

#+end_src

* Expand Region

This module is absolutely necessary for working inside of Emacs Lisp files,
especially when trying to some parent of an expression (like a =setq=).  Makes
tweaking Org agenda views much less annoying.

#+begin_src emacs-lisp

(use-package expand-region
  :bind (("M-[" . er/expand-region)
         ("M-]" . er/contract-region)
         ("C-(" . er/mark-outside-pairs)
         ("C-)" . er/mark-inside-pairs)))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-expand-region"

#+end_src

* Editing Configuration
** Use spaces instead of tabs for indentation

#+begin_src emacs-lisp

(setq-default indent-tabs-mode nil)

#+end_src

** Whitespace

#+begin_src emacs-lisp

(setq-default show-trailing-whitespace t)
(dolist (hook '(special-mode-hook
                term-mode-hook
                comint-mode-hook
                compilation-mode-hook
                minibuffer-setup-hook))
  (add-hook hook
            (lambda () (setq show-trailing-whitespace nil))))

#+end_src

* Use Parinfer for Lispy languages

#+begin_src emacs-lisp

(use-package parinfer
  :disabled
  :hook ((clojure-mode . parinfer-mode)
         (emacs-lisp-mode . parinfer-mode)
         (common-lisp-mode . parinfer-mode)
         (scheme-mode . parinfer-mode)
         (lisp-mode . parinfer-mode))
  :config
  (setq parinfer-extensions
        '(defaults       ; should be included.
           pretty-parens  ; different paren styles for different modes.
           smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab.
           smart-yank)))  ; Yank behavior depend on mode.

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-parinfer-mode"

#+end_src

** Origami.el for Folding

#+begin_src emacs-lisp

(use-package origami
  :hook (yaml-mode . origami-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-origami-el"

#+end_src

* Window Management
** Control Buffer Placement

Emacs' default buffer placement algorithm is pretty disruptive if you like
setting up window layouts a certain way in your workflow. The
=display-buffer-alist= video controls this behavior and you can customize it to
prevent Emacs from popping up new windows when you run commands.

#+begin_src emacs-lisp

(setq display-buffer-base-action
      '(display-buffer-reuse-mode-window
        display-buffer-reuse-window
        display-buffer-same-window))

;; If a popup does happen, don't resize windows to be equal-sized
(setq even-window-sizes nil)

#+end_src

* Credential Management

I use [[https://www.passwordstore.org/][pass]] to manage all of my passwords
locally.

#+begin_src emacs-lisp

(use-package pass)

(setq auth-sources '(password-store))
(setq auth-source-debug t)
(setq auth-source-do-cache nil)
(setq auth-source-pass-filename "~/.password-store")

(use-package auth-source-pass
  :init (auth-source-pass-enable))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-pass"

"emacs-auth-source-pass"

#+end_src

* File Browsing

** Dired

#+begin_src emacs-lisp :tangle no

(use-package dired
  :defer 1
  :ensure nil
  :hook (dired-mode . dired-hide-details-mode)
  :bind (:map dired-mode-map
              ("C-b" . dired-single-up-directory)
              ("C-f" . dired-single-buffer))
  :commands (dired dired-jump)
  :config
  (setq dired-listing-switches "-agho --group-directories-first"
        dired-omit-verbose nil)

  (defun find-text-files ()
    "Find all text files in path recursively, not in .git directory."
    (interactive)
    (find-dired default-directory
                "-type f \
               -not -path \"*/.git/*\" \
               -not -path \"*.pdf\" \
               -not -path \"*.zip\" \
               -not -path \"*.png\" \
               -not -path \"*.jpg\" \
               -not -path \"*.gif\" \
               -not -path \"*.exe\" \
               -not -path \"*.odt\""))

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode)))

#+end_src

#+begin_src emacs-lisp :tangle no

(use-package dired-hide-dotfiles
  :hook (dired-mode . dired-hide-dotfiles-mode)
  :bind (:map dired-mode-map
              ("." . dired-hide-dotfiles-mode)))

#+end_src

#+begin_src emacs-lisp :tangle no

(use-package dired-single
  :after dired
  :bind (:map dired-mode-map
              ("C-b" . dired-single-up-directory)
              ("C-f" . dired-single-buffer)))

#+end_src

#+begin_src emacs-lisp :tangle no

(use-package dired-subtree
  :after dired
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-cycle)))

(use-package dired-collapse
  :after dired
  :hook (dired-mode . dired-collapse-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

;;"emacs-dired-single"

#+end_src

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
;; "emacs-dired-hacks"

;; "emacs-all-the-icons-dired"

#+end_src

** Dirvish

#+begin_src emacs-lisp

  (use-package dirvish
    :init
    (dirvish-override-dired-mode)
    :custom
    (dirvish-quick-access-entries ; It's a custom option, `setq' won't work
     '(("h" "~/" "Home")
       ("d" "~/Downloads/" "Downloads")
       ("." "~/.dotfiles/" "Dotfiles")
       ("a" "~/Repositories/arduino" "Arduino")
       ("g" "~/Repositories/guix" "Guix")
       ("k" "~/Repositories/kicad" "Kicad")
       ("o" "~/Repositories/peter/org" "Org")
       ("p" "~/Repositories/pypi" "Pypi")
       ("r" "~/Repositories/ros" "Ros")
       ))
    :config
    ;; (dirvish-peek-mode) ; Preview files in minibuffer
    ;; (dirvish-side-follow-mode) ; similar to `treemacs-follow-mode'
    ;; (setq dirvish-mode-line-format
    ;;       '(:left (sort symlink) :right (omit yank index)))
    ;; (setq dirvish-attributes
    ;;       '(all-the-icons file-time file-size collapse subtree-state vc-state git-msg))
    ;; (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches
          "-l --almost-all --human-readable --group-directories-first --no-group")
    :bind ; Bind `dirvish|dirvish-side|dirvish-dwim' as you see fit
    (("C-c f" . dirvish-fd)
     :map dirvish-mode-map ; Dirvish inherits `dired-mode-map'
     ("a"   . dirvish-quick-access)
     ("f"   . dirvish-file-info-menu)
     ("y"   . dirvish-yank-menu)
     ("N"   . dirvish-narrow)
     ;; ("^"   . dirvish-history-last)
     ("h"   . dirvish-history-jump) ; remapped `describe-mode'
     ("s"   . dirvish-quicksort)    ; remapped `dired-sort-toggle-or-edit'
     ("v"   . dirvish-vc-menu)      ; remapped `dired-view-file'
     ("TAB" . dirvish-subtree-toggle)
     ("M-f" . dirvish-history-go-forward)
     ("M-b" . dirvish-history-go-backward)
     ("M-l" . dirvish-ls-switches-menu)
     ("M-m" . dirvish-mark-menu)
     ("M-t" . dirvish-layout-toggle)
     ("M-s" . dirvish-setup-menu)
     ("M-e" . dirvish-emerge-menu)
     ("M-j" . dirvish-fd-jump))
    )

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-dirvish"

"emacs-fd"

"poppler"

"ffmpegthumbnailer"

"mediainfo"

"unzip"

"tar"

#+end_src

* Opening Files Externally

#+begin_src emacs-lisp

;; (use-package openwith
;;   :config
;;   (setq openwith-associations
;;         (list
;;          (list (openwith-make-extension-regexp
;;                 '("mpg" "mpeg" "mp3" "mp4"
;;                   "avi" "wmv" "wav" "mov" "flv"
;;                   "ogm" "ogg" "mkv"))
;;                "mpv"
;;                '(file))
;;          (list (openwith-make-extension-regexp
;;                 '("xbm" "pbm" "pgm" "ppm" "pnm"
;;                   "png" "gif" "bmp" "tif" "jpeg")) ;; Removed jpg because Telega was
;;                ;; causing feh to be opened...
;;                "feh"
;;                '(file))
;;          (list (openwith-make-extension-regexp
;;                 '("pdf"))
;;                "zathura"
;;                '(file))))
;;   (openwith-mode 1))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-openwith"

#+end_src

* Search

** ripgrep

#+begin_src emacs-lisp

(require 'rg)
(rg-enable-default-bindings)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-rg"

#+end_src

* Web Browsing

** firefox

#+begin_src emacs-lisp

(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "firefox")

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
#+end_src

** Edit with Emacs

#+begin_src emacs-lisp

(use-package edit-server
  :ensure t
  :commands edit-server-start
  :init (if after-init-time
              (edit-server-start)
            (add-hook 'after-init-hook
                      #'(lambda() (edit-server-start))))
  :config (setq edit-server-new-frame-alist
                '((name . "Edit with Emacs FRAME")
                  (top . 200)
                  (left . 200)
                  (width . 80)
                  (height . 25)
                  (minibuffer . t)
                  (menu-bar-lines . t)
                  (window-system . x))))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-edit-server"

#+end_src

* Dictionary

#+begin_src emacs-lisp

(global-set-key (kbd "C-c l") #'dictionary-lookup-definition)

#+end_src

#+BEGIN_SRC sh :tangle no

sudo apt-get install dictd dict dict-{wn,vera,jargon,devil,gcide,foldoc} && sudo systemctl enable dictd

#+END_SRC

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
#+end_src

* Org Mode

Set up Org Mode with a baseline configuration.  The following sections will add more things to it.

#+begin_src emacs-lisp

;; Turn on indentation and auto-fill mode for Org files
(defun pjp/org-mode-setup ()
  (org-indent-mode)
  (diminish org-indent-mode)
  (variable-pitch-mode 1)
  (auto-fill-mode 0)
  )

(use-package org
  :defer t
  :hook (org-mode . pjp/org-mode-setup)
  :config
  (setq org-ellipsis " ▾"
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-edit-src-content-indentation 2
        org-hide-block-startup nil
        org-src-preserve-indentation t
        org-startup-folded 'content
        org-descriptive-links nil
        org-cycle-separator-lines 2)

  (setq org-modules
        '(org-crypt
          org-habit
          org-bookmark
          org-eshell
          org-irc))

  (setq org-refile-targets '((nil :maxlevel . 1)
                             (org-agenda-files :maxlevel . 1)))

  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-use-outline-path t)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (lisp . t)
     (shell . t)
     (python . t)
     (scheme . t)))

  (setq org-babel-python-command "python3")

  (push '("conf-unix" . conf-unix) org-src-lang-modes)

  ;; NOTE: Subsequent sections are still part of this use-package block!

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-org"

"imagemagick"

#+end_src

** Automatically "Tangle" on Save

Handy tip from [[https://leanpub.com/lit-config/read#leanpub-auto-configuring-emacs-and--org-mode-for-literate-programming][this book]] on literate programming.

#+begin_src emacs-lisp

;; Since we don't want to disable org-confirm-babel-evaluate all
;; of the time, do it around the after-save-hook
(defun pjp/org-babel-tangle-dont-ask ()
  ;; Dynamic scoping to the rescue
  (let ((org-confirm-babel-evaluate nil))
    (org-babel-tangle)))

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'pjp/org-babel-tangle-dont-ask
                                              'run-at-end 'only-in-org-mode)))

#+end_src

** Fonts and Bullets

Set the header font sizes to something more palatable.  A fair amount of inspiration has been taken from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this blog post]].

#+begin_src emacs-lisp

(dolist (face '((org-level-1 . 1.2)
                (org-level-2 . 1.1)
                (org-level-3 . 1.05)
                (org-level-4 . 1.0)
                (org-level-5 . 1.1)
                (org-level-6 . 1.1)
                (org-level-7 . 1.1)
                (org-level-8 . 1.1)))
  (set-face-attribute (car face) nil :font "Iosevka Aile" :weight 'regular :height (cdr face)))

;; Make sure org-indent face is available
(require 'org-indent)

;; Ensure that anything that should be fixed-pitch in Org files appears that way
(set-face-attribute 'org-block nil    :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)

#+end_src

** Block Templates

These templates enable you to type things like =<el= and then hit =Tab= to expand
the template.  More documentation can be found at the Org Mode [[https://orgmode.org/manual/Easy-templates.html][Easy Templates]]
documentation page.

#+begin_src emacs-lisp

;; This is needed as of Org 9.2
(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("sh" . "src sh"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
(add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
(add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
(add-to-list 'org-structure-template-alist '("json" . "src json"))

#+end_src

** Org Roam

#+begin_src emacs-lisp

(use-package org-roam
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory (file-truename "~/Repositories/peter/org/roam"))
  (org-roam-completion-everywhere t)
  (org-roam-completion-system 'default)
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n g" . org-roam-graph)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n c" . org-roam-capture)
         ;; Dailies
         ("C-c n j" . org-roam-dailies-capture-today))
  :config
  (org-roam-db-autosync-mode)
  ;; If using org-roam-protocol
  (require 'org-roam-protocol))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-org-roam"

#+end_src

** End =use-package org-mode=

#+begin_src emacs-lisp

;; This ends the use-package org-mode block
)

#+end_src

** Exporting

#+begin_src emacs-lisp

(setq org-src-fontify-natively t
      org-src-tab-acts-natively t)

(setq org-descriptive-links nil)

(eval-after-load "org"
  '(require 'ox-org nil t))

(eval-after-load "org"
  '(require 'ox-md nil t))

(eval-after-load "org"
  '(require 'ox-gfm nil t))

(defun org-include-img-from-pdf (&rest _)
  "Convert pdf files to image files in org-mode bracket links.

                                                                         # ()convertfrompdf:t # This is a special comment; tells that the upcoming
                                                                                                                                                                # link points to the to-be-converted-to file.
                                                                         # If you have a foo.pdf that you need to convert to foo.png, use the
                                                                         # foo.png file name in the link.
                                                                         [[./foo.png]]
                                                         "
  (interactive)
  (if (executable-find "convert")
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*#\\s-+()convertfrompdf\\s-*:\\s-*t"
                                  nil :noerror)
          ;; Keep on going to the next line till it finds a line with bracketed
          ;; file link.
          (while (progn
                   (forward-line 1)
                   (not (looking-at org-bracket-link-regexp))))
          ;; Get the sub-group 1 match, the link, from `org-bracket-link-regexp'
          (let ((link (match-string-no-properties 1)))
            (when (stringp link)
              (let* ((imgfile (expand-file-name link))
                     (pdffile (expand-file-name
                               (concat (file-name-sans-extension imgfile)
                                       "." "pdf")))
                     (cmd (concat "convert -density 96 -quality 85 "
                                  pdffile " " imgfile)))
                (when (and (file-readable-p pdffile)
                           (file-newer-than-file-p pdffile imgfile))
                  ;; This block is executed only if pdffile is newer than
                  ;; imgfile or if imgfile does not exist.
                  (shell-command cmd)
                  (message "%s" cmd)))))))
    (user-error "`convert' executable (part of Imagemagick) is not found")))

;; (defun my/org-include-img-from-pdf-before-save ()
;;   "Execute `org-include-img-from-pdf' just before saving the file."
;;     (add-hook 'before-save-hook #'org-include-img-from-pdf nil :local))
;; (add-hook 'org-mode-hook #'my/org-include-img-from-pdf-before-save)

;; If you want to attempt to auto-convert PDF to PNG  only during exports, and not during each save.
(with-eval-after-load 'ox
  (add-hook 'org-export-before-processing-hook #'org-include-img-from-pdf))

(defconst help/org-special-pre "^\s*#[+]")
(defun help/org-2every-src-block (fn)
  "Visit every Source-Block and evaluate `FN'."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t))
      (while (re-search-forward (concat help/org-special-pre "BEGIN_SRC") nil t)
        (let ((element (org-element-at-point)))
          (when (eq (org-element-type element) 'src-block)
            (funcall fn element)))))
    (save-buffer)))
;;(define-key org-mode-map (kbd "M-]") (lambda () (interactive)
;;                                                                                                                                                       (help/org-2every-src-block
;;                                                                                                                                                              'org-babel-remove-result)))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-ox-gfm"

#+end_src

* Development

Configuration for various programming languages and dev tools that I use.

** LSP

*** IDE Features with eglot

#+begin_src emacs-lisp

(use-package eglot)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-eglot"

"emacs-consult-eglot"

#+end_src

** DAP

*** Debugging with dap-mode

[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to
Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]]. You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration
docs]] to learn how to configure the debugger for your language. Also make
sure to check out the documentation for the debug adapter to see what
configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp :tangle no

(when pjp/is-gnu
  (use-package dap-mode
    :commands dap-mode
    :hook (dap-stopped . (lambda (arg) (call-interactively #'dap-hydra)))
    :config
    (dap-mode 1)
    (require 'dap-ui)
    (dap-ui-mode 1)
    (require 'dap-lldb)))

#+end_src

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep "" :tangle no

"emacs-dap-mode"

#+end_src

** Company Mode

[[http://company-mode.github.io/][Company Mode]] provides a nicer in-buffer completion interface than
=completion-at-point= which is more reminiscent of what you would expect from an
IDE. We add a simple configuration to make the keybindings a little more useful
(=TAB= now completes the selection and initiates completion at the current
location if needed).

We also use [[https://github.com/sebastiencs/company-box][company-box]] to further enhance the look of the completions with
icons and better overall presentation.

#+begin_src emacs-lisp

(use-package company
  :defer t
  :init (global-company-mode)
  :config
  (progn
    ;; Use Company for completion
    (bind-key [remap completion-at-point] #'company-complete company-mode-map)

    (setq company-tooltip-align-annotations t
          ;; Easy navigation to candidates with M-<n>
          company-show-numbers t)
    (setq company-dabbrev-downcase nil))
  :diminish company-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-company"

#+end_src

** Git

*** Magit

https://magit.vc/manual/magit/

#+begin_src emacs-lisp

(use-package magit
  :commands (magit-status magit-get-current-branch)
  :diminish magit-auto-revert-mode
  :bind (("C-c g" . magit-status))
  :config
  (progn
    (setq magit-completing-read-function 'ivy-completing-read)
    (setq magit-item-highlight-face 'bold))
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-magit"

#+end_src

*** Forge

#+begin_src emacs-lisp

(use-package forge
  :disabled)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

;;"emacs-forge"

#+end_src

*** magit-todos

This is an interesting extension to Magit that shows a TODOs section in your
git status buffer containing all lines with TODO (or other similar words) in
files contained within the repo.  More information at the [[https://github.com/alphapapa/magit-todos][GitHub repo]].

#+begin_src emacs-lisp

(use-package magit-todos
  :defer t)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-magit-todos"

#+end_src

*** Send e-mail for Git patches

OK, this isn't Emacs configuration, but it's relevant to development!

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"git"
"git:send-email"

#+end_src

** Projectile

*** Initial Setup

#+begin_src emacs-lisp

(use-package projectile
  :diminish projectile-mode
  :config (projectile-mode)
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :init
  (when (file-directory-p "~/git")
    (setq projectile-project-search-path '("~/git")))
  (setq projectile-switch-project-action #'projectile-dired))

(use-package counsel-projectile
  :disabled
  :after projectile
  :config
  (counsel-projectile-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-projectile"

"emacs-counsel-projectile"

"ripgrep" ;; For counsel-projectile-rg

"the-silver-searcher" ;; For counsel-projectile-ag

#+end_src

*** Project Configurations

This section contains project configurations for specific projects that I can't
drop a =.dir-locals.el= file into.  Documentation on this approach can be found in
the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Directory-Local-Variables.html][Emacs manual]].

#+begin_src emacs-lisp

#+end_src

** Languages

*** C/C++

#+begin_src emacs-lisp

(use-package ccls)

;; Unfortunately many standard c++ header files have no file
;; extension, and so will not typically be identified by emacs as c++
;; files. The following code is intended to solve this problem.
(require 'cl)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"ccls"

"emacs-ccls"

#+end_src

#+begin_src emacs-lisp

(defun file-in-directory-list-p (file dirlist)
  "Returns true if the file specified is contained within one of
                                        the directories in the list. The directories must also exist."
  (let ((dirs (mapcar 'expand-file-name dirlist))
        (filedir (expand-file-name (file-name-directory file))))
    (and
     (file-directory-p filedir)
     (member-if (lambda (x) ; Check directory prefix matches
                  (string-match (substring x 0 (min(length filedir) (length x))) filedir))
                dirs))))

(defun buffer-standard-include-p ()
  "Returns true if the current buffer is contained within one of
                                        the directories in the INCLUDE environment variable."
  (and (getenv "INCLUDE")
       (file-in-directory-list-p buffer-file-name (split-string (getenv "INCLUDE") path-separator))))

(add-to-list 'magic-fallback-mode-alist '(buffer-standard-include-p . c++-mode))

;; function decides whether .h file is C or C++ header, sets C++ by
;; default because there's more chance of there being a .h without a
;; .cc than a .h without a .c (ie. for C++ template files)
(defun c-c++-header ()
  "sets either c-mode or c++-mode, whichever is appropriate for
                                        header"
  (interactive)
  (let ((c-file (concat (substring (buffer-file-name) 0 -1) "c")))
    (if (file-exists-p c-file)
        (c-mode)
      (c++-mode))))
(add-to-list 'auto-mode-alist '("\\.h\\'" . c-c++-header))
;; and if that doesn't work, a function to toggle between c-mode and
;; c++-mode
(defun c-c++-toggle ()
  "toggles between c-mode and c++-mode"
  (interactive)
  (cond ((string= major-mode "c-mode")
         (c++-mode))
        ((string= major-mode "c++-mode")
         (c-mode))))

(add-to-list 'auto-mode-alist '("\\.ino\\'" . c++-mode))

;; ROS style formatting
(defun ROS-c-mode-hook()
  (setq c-basic-offset 2)
  (setq indent-tabs-mode nil)
  (c-set-offset 'substatement-open 0)
  (c-set-offset 'innamespace 0)
  (c-set-offset 'case-label '+)
  (c-set-offset 'brace-list-open 0)
  (c-set-offset 'brace-list-intro '+)
  (c-set-offset 'brace-list-entry 0)
  (c-set-offset 'member-init-intro 0)
  (c-set-offset 'statement-case-open 0)
  (c-set-offset 'arglist-intro '+)
  (c-set-offset 'arglist-cont-nonempty '+)
  (c-set-offset 'arglist-close '+)
  (c-set-offset 'template-args-cont '+))
(add-hook 'c-mode-common-hook 'ROS-c-mode-hook)
#+end_src

*** Emacs Lisp

#+begin_src emacs-lisp

(add-hook 'emacs-lisp-mode-hook #'flycheck-mode)

(use-package paredit
  :config
  (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)
  )

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-paredit"

#+end_src

*** Scheme

#+begin_src emacs-lisp

;; TODO: This causes issues for some reason.
;; :bind (:map geiser-mode-map
;;        ("TAB" . completion-at-point))

(use-package geiser
  :config
  ;; (setq geiser-default-implementation 'gambit)
  (setq geiser-default-implementation 'guile)
  (setq geiser-active-implementations '(guile))
  (setq geiser-implementations-alist '(((regexp "\\.scm$") guile))))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-geiser"

"emacs-geiser-guile"

#+end_src
*** Markdown

#+begin_src emacs-lisp

(use-package markdown-mode
  :mode "\\.md\\'"
  :config
  (setq markdown-command "marked")
  (defun pjp/set-markdown-header-font-sizes ()
    (dolist (face '((markdown-header-face-1 . 1.2)
                    (markdown-header-face-2 . 1.1)
                    (markdown-header-face-3 . 1.0)
                    (markdown-header-face-4 . 1.0)
                    (markdown-header-face-5 . 1.0)))
      (set-face-attribute (car face) nil :weight 'normal :height (cdr face))))

  (defun pjp/markdown-mode-hook ()
    (pjp/set-markdown-header-font-sizes))

  (add-hook 'markdown-mode-hook 'pjp/markdown-mode-hook))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-markdown-mode"

"emacs-markdown-preview-mode"

#+end_src

*** HTML

#+begin_src emacs-lisp

(use-package web-mode
  :mode "(\\.\\(html?\\|ejs\\|tsx\\|jsx\\)\\'"
  :config
  (setq-default web-mode-code-indent-offset 2)
  (setq-default web-mode-markup-indent-offset 2)
  (setq-default web-mode-attribute-indent-offset 2))

;; 1. Start the server with `httpd-start'
;; 2. Use `impatient-mode' on any buffer
;; (use-package impatient-mode)

;; (use-package skewer-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-web-mode"

#+end_src

*** YAML

#+begin_src emacs-lisp

(use-package yaml-mode
  :mode "\\.ya?ml\\'")

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-yaml-mode"

#+end_src

*** Python


#+begin_src emacs-lisp :tangle no

(use-package python-mode
  :custom
  ;; NOTE: Set these if Python 3 is called "python3" on your system!
  (python-shell-interpreter "python3")
  (dap-python-executable "python3")
  (dap-python-debugger 'debugpy)
  :config
  (require 'dap-python))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"python-lsp-server"

#+end_src

*** Matlab

#+begin_src emacs-lisp :tangle no

(use-package matlab
  :mode "\\.m\\'"
  :config
  (setq matlab-indent-function t)
  (setq matlab-shell-command "matlab"))

#+end_src

** Productivity

*** Syntax checking with Flycheck

#+begin_src emacs-lisp

(use-package flycheck
  :defer t)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-flycheck"

#+end_src

*** Snippets

#+begin_src emacs-lisp

(setq yas-snippet-dirs
      '("~/.emacs.d/snippets"
        "~/.emacs.d/snippets/guix"))
(yas-global-mode 1)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-yasnippet"

"emacs-yasnippet-snippets"

#+end_src

*** Smart Parens

#+begin_src emacs-lisp

(use-package smartparens
  :hook (prog-mode . smartparens-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-smartparens"

#+end_src

*** Rainbow Delimiters

#+begin_src emacs-lisp

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-rainbow-delimiters"

#+end_src

*** Rainbow Mode

Sets the background of HTML color strings in buffers to be the color mentioned.

#+begin_src emacs-lisp

(when pjp/is-gnu
  (use-package rainbow-mode
    :defer t
    :hook (org-mode
           emacs-lisp-mode
           web-mode
           typescript-mode
           js2-mode)))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-rainbow-mode"

#+end_src

** Editing
*** CSV Files

#+begin_src emacs-lisp

(use-package csv)

(use-package csv-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-csv"

"emacs-csv-mode"

#+end_src

* Terminals

** multi-term

#+begin_src emacs-lisp

(use-package multi-term)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-multi-term"

#+end_src

** vterm

[[https://github.com/akermu/emacs-libvterm/][vterm]] is an improved terminal emulator package which uses a compiled native
module to interact with the underlying terminal applications. This enables it
to be much faster than =term-mode= and to also provide a more complete
terminal emulation experience.

Make sure that you have the [[https://github.com/akermu/emacs-libvterm/#requirements][necessary dependencies]] installed before trying to
use =vterm= because there is a module that will need to be compiled before
you can use it successfully.

#+begin_src emacs-lisp

(use-package vterm
  :commands vterm
  :config
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
  ;;(setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
  (setq vterm-max-scrollback 10000)
  (add-hook
   'vterm-mode-hook
   (lambda() (setq show-trailing-whitespace nil)))
  :bind (:map vterm-mode-map
              ("M-n" . multi-vterm-next)
              ("M-p" . multi-vterm-prev)))

(use-package multi-vterm)
(global-set-key (kbd "C-c v") 'multi-vterm)
(global-set-key (kbd "C-c d") 'multi-vterm-dedicated-toggle)

(defun pjp/vterm-execute-region-or-current-line ()
  "Insert text of current line in vterm and execute."
  (interactive)
  (require 'vterm)
  (eval-when-compile (require 'subr-x))
  (let ((command (if (region-active-p)
                     (string-trim (buffer-substring
                                   (save-excursion (region-beginning))
                                   (save-excursion (region-end))))
                   (string-trim (buffer-substring (save-excursion
                                                    (beginning-of-line)
                                                    (point))
                                                  (save-excursion
                                                    (end-of-line)
                                                    (point)))))))
    (let ((buf (current-buffer)))
      (unless (get-buffer vterm-buffer-name)
        (vterm))
      (display-buffer vterm-buffer-name t)
      (switch-to-buffer-other-window vterm-buffer-name)
      (vterm--goto-line -1)
      (message command)
      (vterm-send-string command)
      (vterm-send-return)
      (switch-to-buffer-other-window buf)
      )))
(global-set-key (kbd "C-c x") 'pjp/vterm-execute-region-or-current-line)
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-vterm"

"emacs-multi-vterm"

"emacs-vterm-toggle"

#+end_src

** shell-mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interactive-Shell.html#Interactive-Shell][shell-mode]] is a middle ground between =term-mode= and Eshell. It is *not* a
terminal emulator so more complex terminal programs will not run inside of
it. It does have much better integration with Emacs because all command input
in this mode is handled by Emacs and then sent to the underlying shell once
you press Enter.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-shell-history= - A searchable history of commands typed into the shell

  One advantage of =shell-mode= on Windows is that it's the only way to run
  =cmd.exe=, PowerShell, Git Bash, etc from within Emacs. Here's an example of
  how you would set up =shell-mode= to run PowerShell on Windows:

  #+begin_src emacs-lisp

(when (eq system-type 'windows-nt)
  (setq explicit-shell-file-name "powershell.exe")
  (setq explicit-powershell.exe-args '()))

  #+end_src

** eshell

#+begin_src emacs-lisp

(defun pjp/configure-eshell ()
  ;; Save command history when commands are entered
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

  ;; Truncate buffer for performance
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

  (setq eshell-history-size         10000
        eshell-buffer-maximum-lines 10000
        eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input t))

(use-package eshell
  :hook ((eshell-first-time-mode . pjp/configure-eshell)))

(use-package eshell-up)

(use-package eshell-toggle
  :custom
  (eshell-toggle-size-fraction 4)
  (eshell-toggle-run-command nil)
  :bind
  ("C-c s" . eshell-toggle))

(use-package eshell-syntax-highlighting
  :after eshell-mode
  :config
  ;; Enable in all Eshell buffers.
  (eshell-syntax-highlighting-global-mode +1))

(with-eval-after-load "esh-opt"
  (autoload 'epe-theme-multiline-with-status "eshell-prompt-extras")
  (setq eshell-highlight-prompt nil
        eshell-prompt-function 'epe-theme-multiline-with-status))

;; (with-eval-after-load "esh-opt"
;;   (require 'virtualenvwrapper)
;;   (venv-initialize-eshell)
;;   (autoload 'epe-theme-lambda "eshell-prompt-extras")
;;   (setq eshell-highlight-prompt nil
;;         eshell-prompt-function 'epe-theme-lambda))

;; (eshell-did-you-mean-setup)

(use-package eshell-bookmark
  :after eshell
  :config
  (add-hook 'eshell-mode-hook #'eshell-bookmark-setup))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

;; "emacs-eshell-z"

"emacs-eshell-up"

"emacs-eshell-toggle"

"emacs-eshell-syntax-highlighting"

"emacs-eshell-prompt-extras"

"emacs-eshell-did-you-mean"

"emacs-eshell-bookmark"

#+end_src

* Applications

** Email

My mail configuration is stored in [[file:Email.org][Email.org]]. We merely
require it here to have it loaded in the main Emacs configuration.

#+begin_src emacs-lisp

;; Only fetch mail on knave
;; (setq pjp/mail-enabled (member system-name '("knave" "precision")))
;; (setq pjp/mu4e-inbox-query nil)
;; (when pjp/mail-enabled
;;   (require 'pjp-email))
(global-set-key (kbd "C-c e") (lambda() (interactive) (load "~/.emacs.d/lisp/pjp-email.el")))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-mu4e-alert"

"emacs-org-mime"

#+end_src

** Arduino

#+begin_src emacs-lisp

(setq auto-mode-alist (cons '("\\.\\(pde\\|ino\\)$" . c++-mode) auto-mode-alist))

#+end_src

** PDF

#+begin_src emacs-lisp

(pdf-loader-install)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-pdf-tools"

#+end_src

** plantuml

#+begin_src emacs-lisp

(setq plantuml-default-exec-mode 'executable)
(add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))
(add-to-list
  'org-src-lang-modes '("plantuml" . plantuml))
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"plantuml"

"emacs-plantuml-mode"

#+end_src

* System Utilities
** Guix

#+begin_src emacs-lisp

(use-package guix
  :defer t)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-guix"

#+end_src

** Daemons

#+begin_src emacs-lisp

(use-package daemons
  :commands daemons)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-daemons"

#+end_src

** Docker

#+begin_src emacs-lisp

;; (use-package docker
;;   :commands docker)

;; (use-package docker-tramp
;;   :defer t
;;   :after docker)

(require 'dockerfile-mode)
(add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

;; "emacs-docker"

;; "emacs-docker-tramp"

"emacs-dockerfile-mode"

#+end_src

* Key-chord

#+begin_src emacs-lisp :tangle no

(require 'key-chord)
(key-chord-mode 1)

(key-chord-define-global "sd" 'avy-goto-char-2)
(key-chord-define-global "lk" 'avy-goto-line)

(key-chord-define-global "io" 'scroll-down-command)
(key-chord-define-global "m," 'scroll-up-command)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-key-chord"

#+end_src

* Guix Perfect Setup

#+begin_src emacs-lisp

(when pjp/is-gnu
  (with-eval-after-load 'geiser-guile
    (add-to-list 'geiser-guile-load-path "~/guix"))
  (load-file "~/.emacs.d/lisp/copyright.el"))

#+end_src

* Development Environment

** buffer-env

#+begin_src emacs-lisp

(require 'inheritenv)
(add-hook 'hack-local-variables-hook 'buffer-env-update)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-buffer-env"
"emacs-inheritenv"

#+end_src

* System Crafters Settings

#+begin_src emacs-lisp

(recentf-mode 1)
(save-place-mode 1)
(setq use-dialog-box nil)

#+end_src

* Emacs Relay Chat

#+begin_src emacs-lisp :tangle no

;; Require ERC-SASL package
(require 'erc-sasl)

;; Add SASL server to list of SASL servers (start a new list, if it did not exist)
(add-to-list 'erc-sasl-server-regexp-list "irc\\.libera\\.chat")

;; Redefine/Override the erc-login() function from the erc package, so that
;; it now uses SASL
(defun erc-login ()
  "Perform user authentication at the IRC server. (PATCHED)"
  (erc-log (format "login: nick: %s, user: %s %s %s :%s"
                   (erc-current-nick)
                   (user-login-name)
                   (or erc-system-name (system-name))
                   erc-session-server
                   erc-session-user-full-name))
  (if erc-session-password
      (erc-server-send (format "PASS %s" erc-session-password))
    (message "Logging in without password"))
  (when (and (featurep 'erc-sasl) (erc-sasl-use-sasl-p))
    (erc-server-send "CAP REQ :sasl"))
  (erc-server-send (format "NICK %s" (erc-current-nick)))
  (erc-server-send
   (format "USER %s %s %s :%s"
           ;; hacked - S.B.
           (if erc-anonymous-login erc-email-userid (user-login-name))
           "0" "*"
           erc-session-user-full-name))
  (erc-update-mode-line))

#+end_src

#+begin_src emacs-lisp :tangle no

(setq erc-server "irc.libera.chat"
      erc-nick "peterpolidoro"    ; Change this!
      erc-user-full-name "Peter Polidoro"  ; And this!
      erc-track-shorten-start 8
      erc-autojoin-channels-alist '(("irc.libera.chat" "#systemcrafters" "#emacs" "#guix"))
      erc-kill-buffer-on-part t
      erc-auto-query 'bury)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

#+end_src

* Emacs Profile

*.config/guix/manifests/emacs.scm:*

#+begin_src scheme :scheme guile :session guile :tangle .config/guix/manifests/emacs.scm :noweb yes

(specifications->manifest
 '("emacs"
   <<packages>>
   ))

#+end_src
